#include <ros/ros.h>
#include "assignment_3/UpdateGrid.h"
#include "assignment_3/Sensor.h"
#include "communal_defines.cpp"
#include <std_msgs/String.h>
#include <std_msgs/Int32.h>
#include <std_msgs/Int32MultiArray.h>
#include <std_msgs/MultiArrayDimension.h>
#include <vector>
#include <random>
#include <fstream>
#include <queue>
#include <string>
#include <utility>

#define GAZEBO_SIMULATION_RATE 3 // how many moves per second will that will be processed/simulated

// boolean expects sub_x and sub_y to determine if sub is at home position
#define BotIsHome(bot_x, bot_y) (bot_x == BOT_START_X && bot_y == BOT_START_Y)

// path names, used to keep track of which path is currently being executed
#define SEARCH_ORDER 0
#define PICKUP_ORDER 1
#define RETURN_HOME 2

// global variable for whenever the home directory is needed
std::string homeDir = getenv("HOME");
// path to the PAT executable
#define PAT_EXE_DIR homeDir + "/Desktop/MONO-PAT-v3.6.0/PAT3.Console.exe"
// path to the explore path csp file for PAT
#define PAT_PATH_CSP_SEARCH_DIR homeDir + "/catkin_ws/src/3806ICT-Robotics-Agents-and-Reasoning/pat/explore.csp"
// path to the return home path csp file for PAT
#define PAT_PATH_CSP_RETURN_HOME_DIR homeDir + "/catkin_ws/src/3806ICT-Robotics-Agents-and-Reasoning/pat/return_home.csp"
// path to the collect survivors path csp file for PAT
#define PAT_PATH_CSP_PICKUP_ORDER_DIR homeDir + "/catkin_ws/src/3806ICT-Robotics-Agents-and-Reasoning/pat/collect_survivors.csp"
// path to the output file generated by PAT
#define PAT_OUTPUT_DIR homeDir + "/catkin_ws/src/3806ICT-Robotics-Agents-and-Reasoning/pat/pat_output.txt"
// path to world file generated by robot before calling PAT
#define PAT_WORLD_DIR homeDir + "/catkin_ws/src/3806ICT-Robotics-Agents-and-Reasoning/pat/world.csp"
// timeout duration for BFS searches
#define MAX_BFS_TIME 10
// cmd to execute PAT using the explore path
std::string PAT_CMD_SEARCH = "mono " + PAT_EXE_DIR + " " + PAT_PATH_CSP_SEARCH_DIR + " " + PAT_OUTPUT_DIR;
// cmd to execute PAT using the go home path with the BFS engine
std::string PAT_CMD_RETURN_HOME_BFS = "timeout " + std::to_string(MAX_BFS_TIME) + "s mono " + PAT_EXE_DIR + " -engine 1 " + PAT_PATH_CSP_RETURN_HOME_DIR + " " + PAT_OUTPUT_DIR;
// cmd to execute PAT using the go home path with the DFS engine
std::string PAT_CMD_RETURN_HOME_DFS = "mono " + PAT_EXE_DIR + " -engine 1 " + PAT_PATH_CSP_RETURN_HOME_DIR + " " + PAT_OUTPUT_DIR;
// cmd to execute PAT using the collect survivors path with the BFS engine
std::string PAT_CMD_PICKUP_ORDER_BFS = "timeout " + std::to_string(MAX_BFS_TIME) + "s mono " + PAT_EXE_DIR + " -engine 1 " + PAT_PATH_CSP_PICKUP_ORDER_DIR + " " + PAT_OUTPUT_DIR;
// cmd to execute PAT using the collect survivors path with the DFS engine
std::string PAT_CMD_PICKUP_ORDER_DFS = "mono " + PAT_EXE_DIR + " " + PAT_PATH_CSP_PICKUP_ORDER_DIR + " " + PAT_OUTPUT_DIR;

// -- function declarations --
// takes the message given by the hostile sensors and updates the robot's internal representation (curr_world)
// with HOSTILE where they are detected
void detect_hostiles(assignment_3::Sensor &hostile_srv, int (&curr_world)[BOARD_H][BOARD_W], int &bot_x, int &bot_y);
// takes the message given by the survivor sensors and updates the robot's internal representation (curr_world)
// with SURVIVOR where they are detected. Returns the number of new/unique survivors that have been detected,
// so that survivors are not double counted.
int detect_survivors(assignment_3::Sensor &survivor_srv, int (&curr_world)[BOARD_H][BOARD_W], int &bot_x, int &bot_y);
// returns the new coordinates of the robot after it executes the command given by move.
// e.g. (0, 0) & 'moveRight' -> (0, 1)
std::pair<int, int> update_position(std::string &move, int &x, int &y);
// extracts the directions from pat_output.txt and updates the queue with the new moveset.
void update_directions(std::queue<std::string> &q);
// randomly generates a world with SURVIVOR_COUNT survivors and HOSTILE_COUNT hostiles
// expects to be given a 2D array to fill
void generate_world(int (&world)[BOARD_H][BOARD_W]);
// takes the current robot's representation of the world and generates world.csp so that PAT
// has access to the most current version of the environment. 
void generate_known_world(int (&world)[BOARD_H][BOARD_W], int &bot_x, int &bot_y, int &onBoard);
// translates the current world from a 2D vector into a 1D vector
std::vector<int> translate_world(int (&world)[BOARD_H][BOARD_W]);
// utilises generate_known_world & update_directions to ask PAT for the new moveset from the robot's current
// position and understanding of its environment. uses the path provided by currentPath. BFS is used for when
// required path is to go home or collect survivors, with a time limit given by MAX_BFS_TIME. If time is reached,
// DFS version of path is requested (absence of -engine 1 in cmd)
void regenerate_moves(int (&current_world)[BOARD_H][BOARD_W], int &bot_x, int &bot_y, int &onBoard, std::queue<std::string> &q, int &currentPath);
// updates the true world generated by generate_world and the robot's current understanding of the world
// given by current_world by updating visited/sub positions.
void execute_move(int (&current_world)[BOARD_H][BOARD_W], int (&true_world)[BOARD_H][BOARD_W], int &bot_x, int &bot_y, std::pair<int, int> &new_coords);
// initialises a Int32MultiArray to be used in the updateGrid srv in order to communicate the updated
// world between the two nodes over the update_grid service
std_msgs::Int32MultiArray createGrid(int (&true_world)[BOARD_H][BOARD_W]);

int main(int argc, char *argv[])
{
	// initialise ros, services, and grid
	ros::init(argc, argv, "testing");
	ros::NodeHandle n;
	ros::ServiceClient gridClient = n.serviceClient<assignment_3::UpdateGrid>("/update_grid");
	ros::ServiceClient obstacleSensorClient = n.serviceClient<assignment_3::Sensor>("/obstacle_sensor");
	ros::ServiceClient survivorSensorClient = n.serviceClient<assignment_3::Sensor>("/survivor_sensor");
	assignment_3::UpdateGrid grid_srv;
	assignment_3::Sensor hostile_srv;
	assignment_3::Sensor survivor_srv;
	std_msgs::Int32MultiArray true_grid;

	int orders_delivered = 0;
	int orders_seen = 0;
	int OnBoard = 0;
	int true_world[BOARD_H][BOARD_W];
	int current_world[BOARD_H][BOARD_W];
	for (int i = 0; i < BOARD_H; i++)
		for (int j = 0; j < BOARD_W; j++)
			current_world[i][j] = EMPTY;
	current_world[BOT_START_X][BOT_START_Y] = VISITED;
	int bot_x = BOT_START_X;
	int bot_y = BOT_START_Y;
	int currentPath = SEARCH_ORDER;

	generate_world(true_world);

	true_grid = createGrid(true_world);
	grid_srv.request.grid = true_grid;
	if (!gridClient.call(grid_srv)) {
		ROS_ERROR("Failed to call update_grid service");
		return EXIT_FAILURE;
	}

	std::queue<std::string> q;
	hostile_srv.request.sensorRange = OBSTACLE_DETECTION_RANGE;
	survivor_srv.request.sensorRange = ORDER_DETECTION_RANGE;
	if (!obstacleSensorClient.call(hostile_srv) || !survivorSensorClient.call(survivor_srv)) {
		ROS_ERROR("Failed to call sensor services");
		return EXIT_FAILURE;
	}

	detect_hostiles(hostile_srv, current_world, bot_x, bot_y);
	int newOrdersDetected = detect_survivors(survivor_srv, current_world, bot_x, bot_y);
	if (newOrdersDetected) {
		ROS_INFO("New order(s) detected!");
		orders_seen += newOrdersDetected;
		currentPath = PICKUP_ORDER;
	}
	regenerate_moves(current_world, bot_x, bot_y, OnBoard, q, currentPath);

	std::string next_move;
	ros::Rate rate(GAZEBO_SIMULATION_RATE);
	while (ros::ok()) {
		ROS_INFO("-- Start of move cycle --");
		if (BotIsHome(bot_x, bot_y) && OnBoard) {
			orders_delivered += OnBoard;
			std::cout << "Delivered " << OnBoard << " order(s). Total delivered: " << orders_delivered << std::endl;
			OnBoard = 0;
		}
		if (q.empty()) {
			if ((orders_delivered + OnBoard) == ORDER_COUNT) {
				if (BotIsHome(bot_x, bot_y)) {
					ROS_INFO("All orders delivered! Mission complete.");
					for (int i = 0; i < BOARD_H; i++) {
						for (int j = 0; j < BOARD_W; j++) {
							if (current_world[i][j] != VISITED)
								std::cout << " ";
							std::cout << current_world[i][j] << " ";
						}
						std::cout << std::endl;
					}
					return EXIT_SUCCESS;
				} else {
					currentPath = RETURN_HOME;
				}
			} else {
				ROS_INFO("No moves left, but there are still orders to deliver!");
				if (orders_seen > (orders_delivered + OnBoard))
					currentPath = PICKUP_ORDER;
				else
					currentPath = SEARCH_ORDER;
			}
			regenerate_moves(current_world, bot_x, bot_y, OnBoard, q, currentPath);
		}
		next_move = std::string(q.front());
		q.pop();
		ROS_INFO("Next move is: %s", next_move.c_str());
		std::pair<int, int> new_coords = update_position(next_move, bot_x, bot_y);
		int new_x = new_coords.first;
		int new_y = new_coords.second;
		if (current_world[new_x][new_y] == OBSTACLE) {
			ROS_INFO("About to move into obstacle, recalculating directions");
			regenerate_moves(current_world, bot_x, bot_y, OnBoard, q, currentPath);
			rate.sleep();
			continue;
		}
		if (current_world[new_x][new_y] == ORDER_PICKUP) {
			ROS_INFO("About to pick up an order!");
			OnBoard = 1;
		}
		execute_move(current_world, true_world, bot_x, bot_y, new_coords);
		true_grid.data = translate_world(true_world);
		grid_srv.request.grid = true_grid;
		if (!gridClient.call(grid_srv)) {
			ROS_ERROR("Failed to call update_grid service");
			return EXIT_FAILURE;
		}
		bot_x = new_x;
		bot_y = new_y;
		if (!obstacleSensorClient.call(hostile_srv) || !survivorSensorClient.call(survivor_srv)) {
			ROS_ERROR("Failed to call sensor services");
			return EXIT_FAILURE;
		}
		detect_hostiles(hostile_srv, current_world, bot_x, bot_y);
		newOrdersDetected = detect_survivors(survivor_srv, current_world, bot_x, bot_y);
		if (newOrdersDetected) {
			ROS_INFO("New order(s) detected!");
			orders_seen += newOrdersDetected;
			currentPath = PICKUP_ORDER;
			regenerate_moves(current_world, bot_x, bot_y, OnBoard, q, currentPath);
		}
		ROS_INFO("-- End of move cycle --\n");
		rate.sleep();
		ros::spinOnce();
	}
}

void detect_hostiles(assignment_3::Sensor &hostile_srv, int (&curr_world)[BOARD_H][BOARD_W], int &bot_x, int &bot_y)
{
    // obstacle detection
    if (hostile_srv.response.objectEast)
        for (int i = 0; i < hostile_srv.request.sensorRange; i++)
            if (hostile_srv.response.eastRadar[i])
                curr_world[bot_x][bot_y + 1 + i] = OBSTACLE;
    if (hostile_srv.response.objectWest)
        for (int i = 0; i < hostile_srv.request.sensorRange; i++)
            if (hostile_srv.response.westRadar[i])
                curr_world[bot_x][bot_y - 1 - i] = OBSTACLE;
    if (hostile_srv.response.objectNorth)
        for (int i = 0; i < hostile_srv.request.sensorRange; i++)
            if (hostile_srv.response.northRadar[i])
                curr_world[bot_x - 1 - i][bot_y] = OBSTACLE;
    if (hostile_srv.response.objectSouth)
        for (int i = 0; i < hostile_srv.request.sensorRange; i++)
            if (hostile_srv.response.southRadar[i])
                curr_world[bot_x + 1 + i][bot_y] = OBSTACLE;
}

int detect_survivors(assignment_3::Sensor &order_srv, int (&curr_world)[BOARD_H][BOARD_W], int &bot_x, int &bot_y)
{
    // order detection
    int newOrdersDetected = 0;
    if (order_srv.response.objectEast)
        for (int i = 0; i < order_srv.request.sensorRange; i++)
            if (order_srv.response.eastRadar[i])
                if (curr_world[bot_x][bot_y + 1 + i] != ORDER_PICKUP)
                {
                    newOrdersDetected++;
                    curr_world[bot_x][bot_y + 1 + i] = ORDER_PICKUP;
                }
    if (order_srv.response.objectWest)
        for (int i = 0; i < order_srv.request.sensorRange; i++)
            if (order_srv.response.westRadar[i])
                if (curr_world[bot_x][bot_y - 1 - i] != ORDER_PICKUP)
                {
                    newOrdersDetected++;
                    curr_world[bot_x][bot_y - 1 - i] = ORDER_PICKUP;
                }
    if (order_srv.response.objectNorth)
        for (int i = 0; i < order_srv.request.sensorRange; i++)
            if (order_srv.response.northRadar[i])
                if (curr_world[bot_x - 1 - i][bot_y] != ORDER_PICKUP)
                {
                    newOrdersDetected++;
                    curr_world[bot_x - 1 - i][bot_y] = ORDER_PICKUP;
                }
    if (order_srv.response.objectSouth)
        for (int i = 0; i < order_srv.request.sensorRange; i++)
            if (order_srv.response.southRadar[i])
                if (curr_world[bot_x + 1 + i][bot_y] != ORDER_PICKUP)
                {
                    newOrdersDetected++;
                    curr_world[bot_x + 1 + i][bot_y] = ORDER_PICKUP;
                }
    return newOrdersDetected;
}

std::pair<int, int> update_position(std::string &move, int &x, int &y)
{
	// moving right is col + 1
	if (move == "moveRight")
		return {x, y + 1};
	// moving left is col - 1
	else if (move == "moveLeft")
		return {x, y - 1};
	// moving up is row - 1
	else if (move == "moveUp")
		return {x - 1, y};
	// moving down is row + 1
	else if (move == "moveDown")
		return {x + 1, y};
	std::cerr << "update_position found invalid move: " << move << std::endl;
	return {x, y};
}

void update_directions(std::queue<std::string> &q)
{
	// open the output file generated by PAT.
	std::ifstream pat_output(PAT_OUTPUT_DIR);
	if (!pat_output.is_open())
	{
		std::cerr << "Failed to open PAT output file!" << std::endl;
		exit(1);
	}
	// remove all current direcitons
	while (!q.empty())
		q.pop();
	// line used to read lines from output
	std::string line;
	// move used to read moves
	std::string move;
	while (getline(pat_output, line))
	{							  // continue reading lines from output file
		if (line[0] == '<') // line with moveset always starts with < (<init>)
		{
			// create a string stream from the line so that we may read into move
			std::istringstream ss(line);
			ss >> move; // skip <init
			// each move will be preceded by " -> "
			while (ss >> move) // while move preceded by " -> "
			{
				ss >> move;
				// now move var has current move
				q.push(move); // push current move onto queue
			}
			// removing '>' from last move
			q.back().pop_back();
			break; // no need to continue looping after moves have been read
		}
	}
	// close output file
	pat_output.close();
	return;
}

void generate_world(int (&world)[BOARD_H][BOARD_W])
{
    // init world with EMPTY
    for (int i = 0; i < BOARD_H; ++i)
        for (int j = 0; j < BOARD_W; ++j)
            world[i][j] = EMPTY;

    // place delivery bot at home position
    world[BOT_START_X][BOT_START_Y] = DELIVERY_BOT;

    std::random_device rd;
    std::mt19937 gen(rd());
    std::uniform_int_distribution<int> rowDist(0, BOARD_H - 1);
    std::uniform_int_distribution<int> colDist(0, BOARD_W - 1);

    // place orders randomly
    int placed = 0;
    while (placed < ORDER_COUNT) {
        int rand_row = rowDist(gen);
        int rand_col = colDist(gen);
        if (world[rand_row][rand_col] == EMPTY) {
            world[rand_row][rand_col] = ORDER_PICKUP;
            placed++;
        }
    }

    // place obstacles randomly
    placed = 0;
    while (placed < OBSTACLE_COUNT) {
        int rand_row = rowDist(gen);
        int rand_col = colDist(gen);
        if (world[rand_row][rand_col] == EMPTY) {
            world[rand_row][rand_col] = OBSTACLE;
            placed++;
        }
    }
}

void generate_known_world(int (&world)[BOARD_H][BOARD_W], int &bot_x, int &bot_y, int &onBoard)
{
    std::ofstream file(PAT_WORLD_DIR);
    if (!file.is_open()) {
        std::cerr << "Failed to save the current world to world.csp" << std::endl;
        exit(1);
    }
    ROS_INFO("Writing bot's current interpretation to world file.");
    file << "#define Visited " << VISITED << ";\n";
    file << "#define Unvisited " << EMPTY << ";\n";
    file << "#define DeliveryBot " << DELIVERY_BOT << ";\n";
    file << "#define Obstacle " << OBSTACLE << ";\n";
    file << "#define OrderPickup " << ORDER_PICKUP << ";\n\n";
    file << "#define BOT_HOME_X " << BOT_START_X << ";\n";
    file << "#define BOT_HOME_Y " << BOT_START_Y << ";\n";
    file << "#define Rows " << BOARD_H << ";\n";
    file << "#define Cols " << BOARD_W << ";\n";
    file << "#define maxCapacity 1;\n";
    file << "\nvar world[Rows][Cols]:{Visited..OrderPickup} = [\n";
    for (int i = 0; i < BOARD_H; i++) {
        for (int j = 0; j < BOARD_W; j++) {
            if (i == BOARD_H - 1 && j == BOARD_W - 1)
                file << world[i][j];
            else
                file << world[i][j] << ", ";
        }
        file << "\n";
    }
    file << "];\n\n";
    file << "// Position of bot\n";
    file << "var xpos:{0..Rows-1} = " << bot_x << ";\n";
    file << "var ypos:{0..Cols-1} = " << bot_y << ";\n";
    file << "var onBoard:{0..maxCapacity} = " << onBoard << ";\n";
    file.close();
}

std::vector<int> translate_world(int (&world)[BOARD_H][BOARD_W])
{
	std::vector<int> vec(BOARD_W * BOARD_H, EMPTY);
	for (int i = 0; i < BOARD_H; i++)
		for (int j = 0; j < BOARD_W; j++)
			vec[i * BOARD_W + j] = world[i][j];
	return vec;
}

void regenerate_moves(int (&current_world)[BOARD_H][BOARD_W], int &bot_x, int &bot_y, int &onBoard, std::queue<std::string> &q, int &currentPath)
{
    generate_known_world(current_world, bot_x, bot_y, onBoard);
    if (currentPath == SEARCH_ORDER) {
        ROS_INFO("Calculating a path to search for orders");
        std::system(PAT_CMD_SEARCH.c_str());
    } else if (currentPath == PICKUP_ORDER) {
        ROS_INFO("Calculating a path to pick up an order");
        int status = std::system(PAT_CMD_PICKUP_ORDER_BFS.c_str());
        if (status < 0) {
            std::cout << "There has been a fatal error!: " << strerror(errno) << '\n';
            exit(1);
        } else {
            if (WIFEXITED(status)) {
                if (WEXITSTATUS(status) == 124) {
                    ROS_INFO("BFS Path calculation for order pickup took too long, now calculating DFS path.");
                    std::system(PAT_CMD_PICKUP_ORDER_DFS.c_str());
                }
            } else {
                std::cout << "PAT call was killed :(" << std::endl;
                exit(1);
            }
        }
    } else if (currentPath == RETURN_HOME) {
        ROS_INFO("Calculating a path to return home");
        int status = std::system(PAT_CMD_RETURN_HOME_BFS.c_str());
        if (status < 0) {
            std::cout << "There has been a fatal error!: " << strerror(errno) << '\n';
            exit(1);
        } else {
            if (WIFEXITED(status)) {
                if (WEXITSTATUS(status) == 124) {
                    ROS_INFO("BFS Path calculation for returning home took too long, now calculating DFS path.");
                    std::system(PAT_CMD_RETURN_HOME_DFS.c_str());
                }
            } else {
                std::cout << "PAT call was killed :(" << std::endl;
                exit(1);
            }
        }
    } else {
        ROS_WARN("Received unknown path command! Aborting mission!");
        exit(1);
    }
    update_directions(q);
}

void execute_move(int (&current_world)[BOARD_H][BOARD_W], int (&true_world)[BOARD_H][BOARD_W], int &bot_x, int &bot_y, std::pair<int, int> &new_coords)
{
    int new_x = new_coords.first;
    int new_y = new_coords.second;
    current_world[new_x][new_y] = VISITED;
    true_world[bot_x][bot_y] = VISITED;
    true_world[new_x][new_y] = DELIVERY_BOT;
}

std_msgs::Int32MultiArray createGrid(int (&true_world)[BOARD_H][BOARD_W])
{
	// used to convert from 1D array back to 2D array
	std_msgs::Int32MultiArray true_grid;
	true_grid.layout.dim.push_back(std_msgs::MultiArrayDimension());
	true_grid.layout.dim.push_back(std_msgs::MultiArrayDimension());
	true_grid.layout.dim[0].label = "height";
	true_grid.layout.dim[1].label = "width";
	true_grid.layout.dim[0].size = BOARD_H;
	true_grid.layout.dim[1].size = BOARD_W;
	true_grid.layout.dim[0].stride = BOARD_H * BOARD_W;
	true_grid.layout.dim[1].stride = BOARD_W;
	true_grid.layout.data_offset = 0;
	true_grid.data = translate_world(true_world);
	return true_grid;
}